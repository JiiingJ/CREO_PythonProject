import json
import logging
import abc
import datetime
import pickle
import uuid
from collections import defaultdict
from multiprocessing import shared_memory
from typing import Self
from PyQuantKit import MarketData
import numpy as np
import plotly.graph_objects as go
from scipy.stats import norm
from PyQuantKit import TradeData
from collections import defaultdict



LOGGER = logging.Logger('factor')

__all__ = ['MDS', 'MarketDataService', 'MarketDataMonitor', 'MonitorManager', 'Profile']



class MarketDataMonitor(object, metaclass=abc.ABCMeta):
    """
    this is a template for market data monitor

    A data monitor is a module that process market data and generate custom index

    When MDS receive an update of market data, the __call__ function of this monitor is triggered.

    Note: all the market_data, of all subscribed ticker will be fed into monitor. It should be assumed that a storage for multiple ticker is required.
    To access the monitor, use `monitor = MDS[monitor_id]`
    To access the index generated by the monitor, use `monitor.value`
    To indicate that the monitor is ready to use set `monitor.is_ready = True`

    The implemented monitor should be initialized and use `MDS.add_monitor(monitor)` to attach onto the engine
    """

    def __init__(self, name: str, monitor_id: str = None):
        self.name: str = name
        self.monitor_id: str = uuid.uuid4().hex if monitor_id is None else monitor_id
        self.enabled: bool = True

    @abc.abstractmethod
    def __call__(self, market_data: MarketData, **kwargs):
        ...

    def __reduce__(self):
        return self.__class__.from_json, (self.to_json(),)

    @abc.abstractmethod
    def to_json(self, fmt='str') -> dict | str:
        ...

    @classmethod
    @abc.abstractmethod
    def from_json(cls, json_message: str | bytes | bytearray | dict) -> Self:
        ...

    def to_shm(self, name: str = None) -> str:
        """
        Put the data of the monitor into python shared memory.
        This function is designed to facilitate multiprocessing.
        Some monitor is not advised to be handled concurrently,
        In which case, raise a NotImplementedError.

        The function is expected to put all data into a sharable list,
        and return the name of the list, which can be set by the given name.
        Default name = self.monitor_id

        Note that this method HAVE NO LOCK, use with caution.
        """
        if name is None:
            name = f'{self.monitor_id}.json'

        data = pickle.dumps(self.to_json(fmt='dict'))
        size = len(data)

        try:
            shm = shared_memory.SharedMemory(name=name)

            if shm.size != size:
                shm.close()
                shm.unlink()
                shm = shared_memory.SharedMemory(create=True, size=size, name=name)
        except FileNotFoundError as _:
            shm = shared_memory.SharedMemory(create=True, size=size, name=name)

        shm.buf[:size] = data
        shm.close()
        return name

    def from_shm(self, name: str = None) -> None:
        """
        retrieve the data and update the monitor from shared memory.
        This function is designed to facilitate multiprocessing.
        """
        return

    @abc.abstractmethod
    def clear(self) -> None:
        ...

    @property
    @abc.abstractmethod
    def value(self) -> dict[str, float] | float:
        ...

    @property
    def is_ready(self) -> bool:
        return True


class MonitorManager(object):
    """
    manage market data monitor

    state codes for the manager
    0: idle
    1: working
    -1: terminating
    """

    def __init__(self):
        self.monitor: dict[str, MarketDataMonitor] = {}

    def __call__(self, market_data: MarketData):
        for monitor_id in self.monitor:
            self._work(monitor_id=monitor_id, market_data=market_data)

    def add_monitor(self, monitor: MarketDataMonitor):
        self.monitor[monitor.monitor_id] = monitor

    def pop_monitor(self, monitor_id: str) -> MarketDataMonitor:
        return self.monitor.pop(monitor_id)

    def _work(self, monitor_id: str, market_data: MarketData):
        monitor = self.monitor.get(monitor_id)
        if monitor is not None and monitor.enabled:
            monitor.__call__(market_data)

    def clear(self):
        self.monitor.clear()


class Profile(object, metaclass=abc.ABCMeta):
    def __init__(
            self,
            session_start: datetime.time | None = None,
            session_end: datetime.time | None = None,
            session_break: tuple[datetime.time, datetime.time] | None = None
    ):
        self.session_start: datetime.time | None = session_start
        self.session_end: datetime.time | None = session_end
        self.session_break: tuple[datetime.time, datetime.time] | None = session_break

    @abc.abstractmethod
    def trade_time_between(self, start_time: datetime.datetime | float, end_time: datetime.datetime | float,
                           **kwargs) -> datetime.timedelta:
        ...

    @abc.abstractmethod
    def in_trade_session(self, market_time: datetime.datetime | float) -> bool:
        ...


class DefaultProfile(Profile):
    def __init__(self):
        super().__init__(
            session_start=datetime.time(0),
            session_end=None,
            session_break=None
        )

    def trade_time_between(self, start_time: datetime.datetime | float, end_time: datetime.datetime | float,
                           **kwargs) -> datetime.timedelta:
        if start_time is not None and isinstance(start_time, (float, int)):
            start_time = datetime.datetime.fromtimestamp(start_time)

        if end_time is not None and isinstance(end_time, (float, int)):
            end_time = datetime.datetime.fromtimestamp(end_time)

        if start_time is None or end_time is None:
            return datetime.timedelta(seconds=0)

        if start_time > end_time:
            return datetime.timedelta(seconds=0)

        return end_time - start_time

    def in_trade_session(self, market_time: datetime.datetime | float) -> bool:
        return True


class MarketDataService(object):
    def __init__(self, profile: Profile = None, **kwargs):
        self.profile = DefaultProfile() if profile is None else profile
        self.synthetic_orderbook = kwargs.pop('synthetic_orderbook', False)
        self.cache_history = kwargs.pop('cache_history', False)

        self._market_price = {}
        self._market_history = defaultdict(dict)
        self._market_time: datetime.datetime | None = None
        self._timestamp: float | None = None

        self._monitor: dict[str, MarketDataMonitor] = {}
        self._monitor_manager = MonitorManager()

    def __call__(self, **kwargs):
        if 'market_data' in kwargs:
            self.on_market_data(market_data=kwargs['market_data'])

    def __getitem__(self, monitor_id: str) -> MarketDataMonitor:
        return self.monitor[monitor_id]

    def add_monitor(self, monitor: MarketDataMonitor):
        self.monitor[monitor.monitor_id] = monitor
        self.monitor_manager.add_monitor(monitor)

    def pop_monitor(self, monitor: MarketDataMonitor = None, monitor_id: str = None, monitor_name: str = None):
        if monitor_id is not None:
            pass
        elif monitor_name is not None:
            for _ in list(self.monitor.values()):
                if _.name == monitor_name:
                    monitor_id = _.monitor_id
            if monitor is None:
                LOGGER.error(f'monitor_name {monitor_name} not registered.')
        elif monitor is not None:
            monitor_id = monitor.monitor_id
        else:
            LOGGER.error('must assign a monitor, or monitor_id, or monitor_name to pop.')
            return None

        self.monitor.pop(monitor_id)
        self.monitor_manager.pop_monitor(monitor_id)

    def on_market_data(self, market_data: MarketData):
        ticker = market_data.ticker
        market_time = market_data.market_time
        timestamp = market_data.timestamp
        market_price = market_data.market_price

        self._market_price[ticker] = market_price
        self._market_time = market_time
        self._timestamp = timestamp

        if self.cache_history:
            self._market_history[ticker][market_time] = market_price

        self.monitor_manager.__call__(market_data=market_data)

    def trade_time_between(self, start_time: datetime.datetime | float, end_time: datetime.datetime | float,
                           **kwargs) -> datetime.timedelta:
        return self.profile.trade_time_between(start_time=start_time, end_time=end_time, **kwargs)

    def in_trade_session(self, market_time: datetime.datetime | float) -> bool:
        return self.profile.in_trade_session(market_time=market_time)

    def clear(self):
        # self._market_price.clear()
        # self._market_time = None
        # self._timestamp = None

        self._market_history.clear()
        self.monitor.clear()
        self.monitor_manager.clear()

    @property
    def market_price(self) -> dict[str, float]:
        result = self._market_price
        return result

    @property
    def market_history(self) -> dict[str, dict[datetime.datetime, float]]:
        result = self._market_history
        return result

    @property
    def market_time(self) -> datetime.datetime | None:
        if self._market_time is None:
            if self._timestamp is None:
                return None
            else:
                return datetime.datetime.fromtimestamp(self._timestamp)
        else:
            return self._market_time

    @property
    def market_date(self) -> datetime.date | None:
        if self.market_time is None:
            return None

        return self._market_time.date()

    @property
    def timestamp(self) -> float | None:
        if self._timestamp is None:
            if self._market_time is None:
                return None
            else:
                return self._market_time.timestamp()
        else:
            return self._timestamp

    @property
    def session_start(self) -> datetime.time | None:
        return self.profile.session_start

    @property
    def session_end(self) -> datetime.time | None:
        return self.profile.session_end

    @property
    def session_break(self) -> tuple[datetime.time, datetime.time] | None:
        return self.profile.session_break

    @property
    def monitor(self) -> dict[str, MarketDataMonitor]:
        return self._monitor

    @property
    def monitor_manager(self) -> MonitorManager:
        return self._monitor_manager

    @monitor_manager.setter
    def monitor_manager(self, manager: MonitorManager):
        self._monitor_manager.clear()

        self._monitor_manager = manager

        for monitor in self.monitor.values():
            self._monitor_manager.add_monitor(monitor=monitor)


class AggregatedTrade(MarketDataMonitor):
    def __init__(self, name: str, monitor_id: str = None):
        super().__init__(name, monitor_id)
        self.buy_trades = defaultdict(float)
        self.sell_trades = defaultdict(float)
        #self.is_ready = False

    def __call__(self, market_data: TradeData, **kwargs):
        if isinstance(market_data, TradeData):
            price = market_data.price
            volume = market_data.volume
            if market_data.side == 1:
                self.buy_trades[price] += volume
            elif market_data.side == -1:
                self.sell_trades[price] += volume

    def to_json(self, fmt='str') -> dict:
        data = {
            'buy_trades': dict(self.buy_trades),
            'sell_trades': dict(self.sell_trades)
        }
        return data if fmt == 'dict' else json.dumps(data)

    @classmethod
    def from_json(cls, json_message: str | bytes | bytearray | dict) -> 'AggregatedTrade':
        if isinstance(json_message, (bytes, bytearray)):
            json_message = json_message.decode()
        data = json.loads(json_message) if isinstance(json_message, str) else json_message
        monitor = cls(name='AggregatedTrade')
        monitor.buy_trades = defaultdict(float, data.get('buy_trades', {}))
        monitor.sell_trades = defaultdict(float, data.get('sell_trades', {}))
        return monitor

    def clear(self) -> None:
        self.buy_trades.clear()
        self.sell_trades.clear()

    @property
    def value(self) -> dict[str, float]:
        return {
            'buy_trades': sum(self.buy_trades.values()),
            'sell_trades': sum(self.sell_trades.values())
        }

    def plot_distribution(self):
        prices_buy = list(self.buy_trades.keys())
        volumes_buy = list(self.buy_trades.values())
        prices_sell = list(self.sell_trades.keys())
        volumes_sell = list(self.sell_trades.values())

        fig = go.Figure()
        fig.add_trace(go.Bar(x=prices_buy, y=volumes_buy, name='Buy Trades'))
        fig.add_trace(go.Bar(x=prices_sell, y=volumes_sell, name='Sell Trades'))

        fig.update_layout(
            title='Trade Volume Distribution',
            xaxis_title='Price',
            yaxis_title='Accumulated Volume',
            barmode='overlay'
        )

        fig.write_html('trade_volume_distribution.html')
        fig.show()

    def fit_distribution(self):
        prices_buy = list(self.buy_trades.keys())
        volumes_buy = list(self.buy_trades.values())
        prices_sell = list(self.sell_trades.keys())
        volumes_sell = list(self.sell_trades.values())

        mean_buy, std_buy = norm.fit(prices_buy)
        mean_sell, std_sell = norm.fit(prices_sell)

        ci_buy = (mean_buy - 1.64 * std_buy, mean_buy + 1.64 * std_buy)
        ci_sell = (mean_sell - 1.64 * std_sell, mean_sell + 1.64 * std_sell)

        return {
            'buy': {
                'mean': mean_buy,
                'std': std_buy,
                'ci': ci_buy
            },
            'sell': {
                'mean': mean_sell,
                'std': std_sell,
                'ci': ci_sell
            }
        }


MDS = MarketDataService()
